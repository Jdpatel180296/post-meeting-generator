# Deployment Guide

This guide covers deploying the Post-Meeting Generator app (Node.js backend + React frontend + PostgreSQL) to production.

## Architecture Overview

- **Backend**: Node.js/Express server (port 4000)

  - OAuth flows (Google, LinkedIn, Facebook)
  - API endpoints (meetings, posts, automations, social accounts)
  - Poller (fetches Recall.ai transcripts every 60s)
  - AI integration (OpenAI for post/email generation)
  - Transcription (AssemblyAI adapter)

- **Frontend**: React app (port 3000 in dev, served from backend in prod)

  - Pages: Login, Events, Past Meetings, Meeting Detail, Settings
  - OAuth redirect handlers
  - SPA routing via React Router

- **Database**: PostgreSQL (15+)
  - Tables: users, meetings, recall_bots, recall_media, social_media_accounts, automations, posts, user_settings

## Deployment Options

### Option 1: Heroku (simplest, recommended for prototypes)

**Pros**: Free tier available, handles scaling, built-in PostgreSQL addon, auto-deploys from Git
**Cons**: Can be slower than bare VPS, limited customization

**Steps**:

1. Install Heroku CLI:

```bash
brew tap heroku/brew && brew install heroku
heroku login
```

2. Create a Heroku app:

```bash
heroku create your-app-name
```

3. Add PostgreSQL addon:

```bash
heroku addons:create heroku-postgresql:hobby-dev
```

4. Set environment variables:

```bash
heroku config:set GOOGLE_CLIENT_ID=your_client_id
heroku config:set GOOGLE_CLIENT_SECRET=your_secret
heroku config:set GOOGLE_REDIRECT_URI=https://your-app-name.herokuapp.com/oauth2callback
heroku config:set RECALL_API_KEY=your_key
heroku config:set OPENAI_API_KEY=your_key
heroku config:set ASSEMBLY_API_KEY=your_key
heroku config:set LINKEDIN_CLIENT_ID=your_id
heroku config:set LINKEDIN_CLIENT_SECRET=your_secret
heroku config:set LINKEDIN_REDIRECT_URI=https://your-app-name.herokuapp.com/api/auth/linkedin/callback
heroku config:set FACEBOOK_APP_ID=your_id
heroku config:set FACEBOOK_APP_SECRET=your_secret
heroku config:set FACEBOOK_REDIRECT_URI=https://your-app-name.herokuapp.com/api/auth/facebook/callback
heroku config:set NODE_ENV=production
```

5. Create a `Procfile` in project root:

```
web: cd server && npm run start
```

6. Build frontend and include in server bundle:

```bash
cd client && npm run build
# Copy build/ to server/public/ so Express can serve it
cp -r build/* ../server/public/
```

7. Update `server/index.js` to serve static frontend files:

```javascript
// Add near the end before app.listen()
app.use(express.static(path.join(__dirname, "public")));
app.get("*", (req, res) =>
  res.sendFile(path.join(__dirname, "public/index.html"))
);
```

8. Deploy:

```bash
git add .
git commit -m "Prepare for Heroku deployment"
git push heroku main
```

9. Run migrations:

```bash
heroku run "cd server && npm run migrate"
```

---

### Option 2: AWS (EC2 + RDS, more control)

**Pros**: Full control, scales well, good free tier, RDS handles DB backups
**Cons**: More configuration, higher learning curve

**Steps**:

1. **Set up RDS PostgreSQL**:

   - Go to AWS RDS console → Create database
   - Engine: PostgreSQL 15
   - DB instance identifier: post-meeting-db
   - Username: postgres
   - Password: (generate strong password)
   - Public accessibility: Yes (restrict by security group)
   - Publicly accessible: No (safer)

2. **Set up EC2 instance**:

   - Launch instance: Ubuntu 22.04 LTS, t2.micro (free tier eligible)
   - Security group: allow ports 22 (SSH), 80 (HTTP), 443 (HTTPS)
   - Allocate elastic IP

3. **SSH into instance**:

```bash
ssh -i your-key.pem ubuntu@your-elastic-ip
```

4. **Install dependencies**:

```bash
sudo apt update && sudo apt upgrade -y
sudo apt install -y nodejs npm postgresql-client git
curl https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
source ~/.bashrc
nvm install 18
nvm use 18
```

5. **Clone repo and set up**:

```bash
git clone https://github.com/your-user/post-meeting-generator.git
cd post-meeting-generator

# Create .env
cat > server/.env << 'EOF'
GOOGLE_CLIENT_ID=your_id
GOOGLE_CLIENT_SECRET=your_secret
GOOGLE_REDIRECT_URI=https://your-domain.com/oauth2callback
RECALL_API_KEY=your_key
OPENAI_API_KEY=your_key
ASSEMBLY_API_KEY=your_key
LINKEDIN_CLIENT_ID=your_id
LINKEDIN_CLIENT_SECRET=your_secret
LINKEDIN_REDIRECT_URI=https://your-domain.com/api/auth/linkedin/callback
FACEBOOK_APP_ID=your_id
FACEBOOK_APP_SECRET=your_secret
FACEBOOK_REDIRECT_URI=https://your-domain.com/api/auth/facebook/callback
PGHOST=your-rds-endpoint
PGPORT=5432
PGUSER=postgres
PGPASSWORD=your-password
PGDATABASE=postmeeting
NODE_ENV=production
EOF

# Build and start
cd client && npm install && npm run build
cd ../server && npm install
npm run migrate
```

6. **Set up PM2 (process manager)**:

```bash
sudo npm install -g pm2
pm2 start "npm run start" --name "post-meeting-server" --cwd server/
pm2 startup
pm2 save
```

7. **Set up Nginx reverse proxy**:

```bash
sudo apt install -y nginx
sudo tee /etc/nginx/sites-available/default > /dev/null << 'EOF'
server {
    listen 80 default_server;
    server_name _;

    location / {
        proxy_pass http://localhost:4000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
EOF

sudo systemctl restart nginx
```

8. **Set up SSL (Let's Encrypt)**:

```bash
sudo apt install -y certbot python3-certbot-nginx
sudo certbot --nginx -d your-domain.com
```

---

### Option 3: Railway.app (modern Heroku alternative)

**Pros**: Easy deployment, good free tier, generous limits, GitHub integration
**Cons**: Smaller community than Heroku

**Steps**:

1. Go to https://railway.app and sign up (GitHub login recommended)

2. Create new project → select "Deploy from GitHub repo"

3. Connect your GitHub repo

4. Railway will auto-detect Node.js and PostgreSQL

5. Add environment variables via Railway dashboard

6. Railway auto-deploys on Git push

---

### Option 4: Docker + any cloud provider (most flexible)

**Pros**: Portable, same environment everywhere, works with AWS ECS, GCP Cloud Run, Azure Container Instances
**Cons**: Requires Docker knowledge

**Create `Dockerfile` (project root)**:

```dockerfile
# Build stage
FROM node:18-alpine AS builder

WORKDIR /app

# Copy and build client
COPY client ./client
WORKDIR /app/client
RUN npm install && npm run build

# Build stage server
WORKDIR /app
COPY server ./server
WORKDIR /app/server
RUN npm install

# Runtime stage
FROM node:18-alpine

WORKDIR /app/server
COPY --from=builder /app/server ./
COPY --from=builder /app/client/build ./public

EXPOSE 4000
CMD ["npm", "run", "start"]
```

**Build and run locally**:

```bash
docker build -t post-meeting-generator .
docker run -p 4000:4000 \
  -e PGHOST=your-db \
  -e PGUSER=postgres \
  -e PGPASSWORD=your-password \
  post-meeting-generator
```

**Deploy to AWS ECS, GCP Cloud Run, or similar**:

```bash
# Push to Docker Hub
docker tag post-meeting-generator your-dockerhub-username/post-meeting-generator
docker push your-dockerhub-username/post-meeting-generator

# Then deploy via cloud provider's UI or CLI
```

---

## Pre-deployment Checklist

- [ ] All environment variables set (see `.env.example` for required keys)
- [ ] PostgreSQL database created and migrated
- [ ] OAuth apps created (Google, LinkedIn, Facebook)
  - Redirect URIs updated to production domain
  - Client IDs/secrets stored in env vars
- [ ] OpenAI API key added (for post/email generation)
- [ ] AssemblyAI API key added (for transcription)
- [ ] Recall.ai API key added (for recording bot)
- [ ] Frontend built and tested
- [ ] Backend tested with all endpoints
- [ ] SSL/HTTPS configured
- [ ] Error logging set up (e.g., Sentry)
- [ ] Backups scheduled (database)
- [ ] Monitoring set up (uptime, error rate, response times)

## Production Tips

1. **Environment variables**: Never commit `.env` to Git. Use `example.env` as template.

2. **Database**:

   - Run migrations on deploy: `npm run migrate`
   - Set up automated backups
   - Use connection pooling (PgBouncer) for high concurrency

3. **Frontend**:

   - Update CORS origins in `server/index.js` to only allow your domain
   - Update Google/LinkedIn/Facebook OAuth redirect URIs to production URLs

4. **Poller**:

   - Runs automatically on server start
   - Monitor logs for polling failures
   - Adjust interval if needed: edit `POLL_INTERVAL_MS` in `.env`

5. **Rate limiting**:

   - Consider adding rate limiting to API (e.g., express-rate-limit)
   - Protect OAuth endpoints from abuse

6. **Logging**:

   - Set up centralized logging (e.g., LogRocket, Sentry, Datadog)
   - Monitor server logs for errors

7. **Monitoring**:
   - Set up uptime monitoring (e.g., UptimeRobot)
   - Alert on high error rates or slow response times

## Rollback / Updates

If you need to roll back:

**Heroku**:

```bash
heroku releases
heroku rollback v42
```

**AWS EC2**:

```bash
cd /path/to/repo
git checkout previous-commit
npm run start
```

**Railway/Docker**: Re-deploy from previous Git commit or image tag.

## Cost Estimates

| Platform             | Tier                 | Monthly Cost           |
| -------------------- | -------------------- | ---------------------- |
| Heroku               | Free                 | $0 (limited)           |
| Heroku               | Standard             | $50+                   |
| AWS                  | Free tier + t2.micro | $10-20                 |
| Railway              | Free                 | $0 (5GB bandwidth)     |
| Railway              | Paid                 | $5+                    |
| Docker (self-hosted) | DIY                  | $5+ (cheapest compute) |

## Support & Troubleshooting

- Check logs: `heroku logs --tail`, `pm2 logs`, or Docker logs
- Database connection issues: verify PGHOST, PGUSER, PGPASSWORD, firewall rules
- OAuth redirects: ensure OAuth app redirect URIs match exactly
- Poller not running: check server logs for poller startup message
- API timeouts: may indicate external service issue (Recall.ai, OpenAI, AssemblyAI)

---

**Which deployment option would you prefer? (Heroku, AWS EC2, Railway, or Docker?)**
